//! Ephemeris initialization helpers
//!
//! This module provides functionality to extract embedded Swiss Ephemeris files
//! and configure the native Swiss Ephemeris library for use.  
//! It uses `rust-embed` to embed ephemeris files at compile time, and extracts
//! them to a permanent cache folder on disk the first time the library is used.
//!
//! Key points:
//! - Embedded files are stored in `EmbeddedEphemeris` (Rust struct) and must exist
//!   at compile time under `src/swisseph/ephe` (or your folder path).
//! - Extraction only occurs if the target cache folder does not already exist.
//! - The native Swiss Ephemeris library is configured every time by calling
//!   `initialize_ephemeris_with_path()`.
//! - Initialization is idempotent: repeated calls do nothing if extraction has already occurred.
use rust_embed::RustEmbed;
use thiserror::Error;

use std::fs;
use std::path::{Path, PathBuf};

use crate::swerust::handler_swe02::{set_ephe_path, version};

/// Type alias for results returned by this module.
pub type Result<T> = std::result::Result<T, EphemerisError>;

/// Errors that may occur during ephemeris extraction or initialization.
#[derive(Debug, Error)]
pub enum EphemerisError {
    #[error("Invalid path: {0:?}")]
    InvalidPath(PathBuf),

    #[error("Path does not exist: {0:?}")]
    PathDoesNotExist(PathBuf),

    #[error("Directory read failed: {0:?}, {1}")]
    DirectoryReadFailed(PathBuf, #[source] std::io::Error),

    #[error("Required files missing in: {0:?}")]
    FilesMissing(PathBuf),

    #[error("Version mismatch, expected: {expected}, found: {found}")]
    VersionMismatch { expected: String, found: String },

    #[error(transparent)]
    Io(std::io::Error),
}

impl From<std::io::Error> for EphemerisError {
    fn from(e: std::io::Error) -> Self {
        EphemerisError::Io(e)
    }
}

/// Represents the embedded ephemeris files.
///
/// This struct is generated by `rust-embed` and contains `.se1`, `.txt`,
/// `.cat`, `.eph` files compiled into the binary at compile time.
/// Use `EmbeddedEphemeris::iter()` to iterate over file names, and
/// `EmbeddedEphemeris::get(file_name)` to get the file data..
#[derive(RustEmbed)]
#[folder = "src/swisseph/ephe"] // your .se1, .txt, .cat, .eph files here
pub struct EmbeddedEphemeris;

/// Ensures that embedded ephemeris files are extracted and the Swiss Ephemeris library is configured.
///
/// - Extracts files from `EmbeddedEphemeris` into a permanent cache directory (if not already present).
/// - Configures the Swiss Ephemeris library to use the extracted files via `initialize_ephemeris_with_path()`.
///
/// # Behavior
/// - Extraction occurs only once per cache folder (i.e., "once forever").
/// - Always sets the library path; safe to call multiple times.
/// - Chooses a permanent location: system cache dir if available, or `target/ephemeris` as fallback.
///
/// # Errors
/// Returns `EphemerisError` if directory creation, file writing, validation, or version check fails.
pub fn ensure_ephemeris_initialized() -> Result<()> {
    // Choose a permanent, shared cache location
    let target = dirs_next::cache_dir()
        .unwrap_or_else(|| PathBuf::from("target"))
        .join("ephemeris");

    // Extract embedded files only if the folder doesn't exist yet
    if !target.exists() {
        fs::create_dir_all(&target)?;

        for file_name in EmbeddedEphemeris::iter() {
            if let Some(file) = EmbeddedEphemeris::get(&file_name) {
                let path = target.join(file_name.as_ref());
                if let Some(parent) = path.parent() {
                    fs::create_dir_all(parent)?;
                }
                fs::write(&path, &file.data)?; // write embedded file
            }
        }
    }

    // Always set the Swiss Ephemeris path (idempotent)
    initialize_ephemeris_with_path(&target)?;

    Ok(())
}

/// Initializes Swiss Ephemeris by validating the extracted files and setting the library path.
///
/// Checks that:
/// - `path` exists and is valid UTF-8,
/// - contains at least one `.se1` file (binary ephemeris) and one `.txt` file (supporting data),
/// - matches the expected Swiss Ephemeris version.
///
/// Calls `set_ephe_path(path)` to configure the native library.
///
/// # Errors
/// Returns `EphemerisError` if path does not exist, files are missing, or version mismatches.
pub fn initialize_ephemeris_with_path<P: AsRef<Path>>(path: P) -> Result<()> {
    let path = path.as_ref();
    let path_str = path
        .to_str()
        .ok_or_else(|| EphemerisError::InvalidPath(path.to_path_buf()))?;

    if !path.exists() {
        return Err(EphemerisError::PathDoesNotExist(path.to_path_buf()));
    }

    // Scan the directory for .se1 and .txt files
    let mut has_se1_files = false;
    let mut has_txt_files = false;

    // Scan directory for files
    for entry in fs::read_dir(path).map_err(|e| {
        EphemerisError::DirectoryReadFailed(path.to_path_buf(), e)
    })? {
        if let Ok(entry) = entry {
            let p = entry.path();
            if let Some(ext) = p.extension().and_then(|e| e.to_str()) {
                match ext {
                    "se1" => has_se1_files = true,
                    "txt" => has_txt_files = true,
                    _ => {},
                }
            }
        }
    }

    if !has_se1_files {
        return Err(EphemerisError::FilesMissing(path.to_path_buf()));
    }
    if !has_txt_files {
        return Err(EphemerisError::FilesMissing(path.to_path_buf()));
    }

    set_ephe_path(path_str);

    // (Optional) If you want JPL DE file instead of Swiss .se1 files:
    // crate::set_jpl_file("/path/to/jpl/de431.eph");

    // Reuse your version function
    let found_version = version();
    let expected_version = "2.10.03";
    if found_version != expected_version {
        return Err(EphemerisError::VersionMismatch {
            expected: expected_version.to_string(),
            found: found_version,
        });
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::env;
    use std::fs::File;
    use std::io::Write;
    use std::path::Path;
    use tempfile::tempdir;

    /// Helper: write an arbitrary dummy file inside `dir` with `name`.
    fn write_dummy(dir: &Path, name: &str) -> std::io::Result<()> {
        let p = dir.join(name);
        if let Some(parent) = p.parent() {
            std::fs::create_dir_all(parent)?;
        }
        let mut f = File::create(&p)?;
        f.write_all(b"dummy")?;
        Ok(())
    }

    #[test]
    fn initialize_ephemeris_with_valid_se1_and_txt() {
        let tmp = tempdir().unwrap();
        let dir = tmp.path();

        // create dummy se1 and txt files
        write_dummy(dir, "dummy.se1").unwrap();
        write_dummy(dir, "somefile.txt").unwrap();

        // Set expected version to current actual version so the version check passes.
        env::set_var("SWE_EXPECTED_VERSION", version());

        // This test uses initialize_ephemeris_with_path directly (no OnceCell),
        // so no interaction with ensure_ephemeris_initialized()'s OnceCell.
        let res = initialize_ephemeris_with_path(dir);
        assert!(res.is_ok(), "expected OK for directory with .se1 and .txt");
    }

    #[test]
    fn initialize_ephemeris_missing_se1_returns_error() {
        let tmp = tempdir().unwrap();
        let dir = tmp.path();

        // only txt present
        write_dummy(dir, "only.txt").unwrap();

        env::set_var("SWE_EXPECTED_VERSION", version());

        let res = initialize_ephemeris_with_path(dir);
        assert!(matches!(res, Err(EphemerisError::FilesMissing(_))));
    }

    #[test]
    fn initialize_ephemeris_missing_txt_returns_error() {
        let tmp = tempdir().unwrap();
        let dir = tmp.path();

        // only se1 present
        write_dummy(dir, "only.se1").unwrap();

        env::set_var("SWE_EXPECTED_VERSION", version());

        let res = initialize_ephemeris_with_path(dir);
        assert!(matches!(res, Err(EphemerisError::FilesMissing(_))));
    }

    #[test]
    fn ensure_ephemeris_initialized_is_idempotent_and_uses_envdir() {
        // Create a unique temp dir for extraction and keep it alive for the test.
        // We set SWE_EPHE_EXTRACT_DIR before the first call so OnceCell uses it.
        let tmp = tempdir().unwrap();
        let extract_dir = tmp.path().to_path_buf();
        env::set_var("SWE_EPHE_EXTRACT_DIR", &extract_dir);

        // Also override expected version to match the runtime version.
        env::set_var("SWE_EXPECTED_VERSION", version());

        // First call: extracts embedded files (if any) and initializes.
        // If your EmbeddedEphemeris folder is empty at compile time, this still
        // runs initialize_ephemeris_with_path on the dir and will fail if
        // there are no .se1/.txt files â€” so in CI you might want to include
        // embedded files or write test files into extract_dir before invoking.
        //
        // For the sake of unit-testing, we will create the minimal required
        // .se1 and .txt files inside `extract_dir` before calling.
        write_dummy(&extract_dir, "dummy.se1").unwrap();
        write_dummy(&extract_dir, "dummy.txt").unwrap();

        // Keep `tmp` alive (do not drop it) while OnceCell caches the path.
        // First initialization should succeed.
        let first = ensure_ephemeris_initialized();
        assert!(first.is_ok(), "first ensure should succeed");

        // Calling again should be a no-op and succeed.
        let second = ensure_ephemeris_initialized();
        assert!(second.is_ok(), "second ensure should also succeed");

        // tmp will be cleaned up when test function returns and tmp is dropped.
    }
}
